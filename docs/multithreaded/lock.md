![img](https://s2.loli.net/2023/11/24/HbhAMgXt6ucPWvs.png)

### 乐观锁 VS 悲观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。java 通常是通过无锁编程来实现，最常用的就是CAS。

![img](https://s2.loli.net/2023/11/24/jgx3eaIVuWq21yf.png)

###  自旋锁 VS 适应性自旋锁

![img](https://s2.loli.net/2023/11/24/wetSCjZQzPElYI3.png)

### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

![img](https://s2.loli.net/2023/11/24/BNEuIUZrbcwSHpL.png)

### 公平锁 VS 非公平锁

![img](https://s2.loli.net/2023/11/24/vxkhUOdwWtQqCRi.png)

### 可重入锁 VS 非可重入锁

### 独享锁(排他锁) VS 共享锁


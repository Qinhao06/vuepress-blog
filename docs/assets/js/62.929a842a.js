(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{500:function(a,t,s){"use strict";s.r(t);var r=s(2),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java-多态底层实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-多态底层实现"}},[a._v("#")]),a._v(" java 多态底层实现")]),a._v(" "),t("h3",{attrs:{id:"java-多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-多态"}},[a._v("#")]),a._v(" java 多态")]),a._v(" "),t("p",[a._v("Java多态（Polymorphism）是指在Java程序中，一个对象引用可以指向多种实际类型，并且可以通过这个引用调用相应类型的属性和方法。这种动态类型识别和动态方法调用，使得程序可以在运行时根据对象的实际类型来执行相应的方法。\nJava多态的实现方式包括接口、继承和方法重写等。通过使用接口或抽象类，可以定义通用的行为和接口，然后由具体的子类实现不同的细节，从而实现多态。同时，Java也支持方法的重载和重写，使得不同的方法可以根据传递的参数类型和数量来执行不同的操作。")]),a._v(" "),t("h3",{attrs:{id:"从静态类型和实际类型看重写如何实现多态-动态分派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从静态类型和实际类型看重写如何实现多态-动态分派"}},[a._v("#")]),a._v(" 从静态类型和实际类型看重写如何实现多态（动态分派）")]),a._v(" "),t("p",[t("code",[a._v("Person man = new Man();")]),a._v("\n在上述代码中 Person 是静态类型，Man 是实际类型（运行时类型）")]),a._v(" "),t("p",[a._v("给出一个例子：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://s2.loli.net/2023/11/22/Rxi9B61zg2rOWoE.png",alt:"Clipboard_2023-11-22-11-25-18"}}),a._v("\n上述例子中在调用say 方法时，都是一样的指令，这就表明在运行时才能确定具体调用的是什么方法，也就实现了多态。而这种在编译期间无法被确定的方法就称为"),t("strong",[a._v("虚方法")]),a._v("。\n而对于继承和实现接口实现的多态就是通过这样的方式实现的。这种也叫做动态分派。\n动态分派：在运行期间根据实际类型确定方法调用的目标方法。它的分派过程是根据实际类型信息发生的，因此也被称为动态类型绑定。最典型的例子是方法重写，即子类中重写了父类中的方法，而父类类型的变量引用了子类对象时，运行时就会根据子类的实际类型调用相应的方法。")]),a._v(" "),t("h3",{attrs:{id:"从静态类型看重载-静态分派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从静态类型看重载-静态分派"}},[a._v("#")]),a._v(" 从静态类型看重载（静态分派）")]),a._v(" "),t("p",[a._v("![](/Users/qh/markdown 文档/attachments/Clipboard_2023-11-22-20-04-12.png)\n代码中可以看出，重载的方法有不同的参数在中有不同的哈希值，也就在编译成 class 文件时就可确定调用的方法。")]),a._v(" "),t("p",[a._v("静态分派：在编译期间确定方法调用的目标方法。它的分派过程是根据静态类型信息发生的，因此也被称为静态类型绑定。最典型的例子是方法重载，即同一个类中定义了多个同名方法，但参数类型或个数不同。根据方法调用时实参的静态类型，编译器可以明确调用哪个方法。")])])}),[],!1,null,null,null);t.default=v.exports}}]);
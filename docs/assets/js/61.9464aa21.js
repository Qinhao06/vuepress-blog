(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{497:function(t,e,n){"use strict";n.r(e);var a=n(2),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"java-多线程学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-多线程学习"}},[t._v("#")]),t._v(" java 多线程学习")]),t._v(" "),e("h3",{attrs:{id:"多线程使用目的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程使用目的"}},[t._v("#")]),t._v(" 多线程使用目的")]),t._v(" "),e("p",[t._v("增加吞吐量，提升利用率\n需要考虑原子性，可见性，有序性")]),t._v(" "),e("h3",{attrs:{id:"原子性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[t._v("#")]),t._v(" 原子性")]),t._v(" "),e("p",[t._v("原子性的操作是不可中断的一个或者一系列操作\n考虑变量带锁，不能在单个线程操作变量的过程中被其他变量获取。\n解决方法：")]),t._v(" "),e("ul",[e("li",[t._v("synchronized关键字")])]),t._v(" "),e("p",[t._v("参考代码：")]),t._v(" "),e("p",[t._v("public class AtomicDemo implements Runnable{")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("private static Integer count =0;\n\nfinal static Object o = new Object();\n\n/**\n * When an object implementing interface <code>Runnable</code> is used\n * to create a thread, starting the thread causes the object's\n * <code>run</code> method to be called in that separately executing\n * thread.\n * <p>\n * The general contract of the method <code>run</code> is that it may\n * take any action whatsoever.\n *\n * @see Thread#run()\n */\n@Override\npublic void run() {\n    synchronized (o){\n        count++;\n    }\n    System.out.println(count);\n}\n\npublic static void main(String[] args) {\n    AtomicDemo atomicDemo = new AtomicDemo();\n    for (int i = 0; i < 10000; i++) {\n        Thread thread = new Thread(atomicDemo);\n        thread.start();\n    }\n    System.out.println(AtomicDemo.count);\n}\n")])])]),e("p",[t._v("}")]),t._v(" "),e("ul",[e("li",[t._v("CAS操作，比如 lock 和AtomicInteger\n代码：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("AtomicInteger atomicInteger = new AtomicInteger(0);\n Lock lock = new ReentrantLock();\n")])])]),e("p",[t._v("在多线程环境下运行时可能会遇到问题。虽然使用ReentrantLock可以保证对i的访问是原子的，但是主线程在打印出i的值时并没有等待其他线程完成，因此可能会导致打印出的值小于1000。为了确保正确性，可以在主线程中使用等待/通知机制来等待所有其他线程完成")]),t._v(" "),e("h3",{attrs:{id:"可见性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[t._v("#")]),t._v(" 可见性")]),t._v(" "),e("p",[t._v("缓存结构导致的线程变量的可见性问题")]),t._v(" "),e("p",[t._v("解决方式：")]),t._v(" "),e("ul",[e("li",[t._v("加锁，会清除工作内存，从主内存中获取")]),t._v(" "),e("li",[t._v("使用volatile变量，被修饰的变量在修改后会被立刻刷回内存，其他线程使用时需要主内存中重新读取。")])]),t._v(" "),e("h3",{attrs:{id:"有序性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[t._v("#")]),t._v(" 有序性")]),t._v(" "),e("p",[t._v("单线程中指令重排没有问题，但是多线程中如果存在执行顺序，如线程 1 等待某个变量为 true后读取某个对象，线程 2初始化对象，随后设置变量为true。指令重排可能导致线程 2 先设置变量，随后执行顺序出现问题。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://s2.loli.net/2023/11/22/H17GUcsVYqeln9C.png",alt:"Clipboard_2023-11-22-10-34-49"}})]),t._v(" "),e("p",[t._v("解决方式：")]),t._v(" "),e("ul",[e("li",[t._v("加锁，单次只有一个线程操作")]),t._v(" "),e("li",[t._v("volatile关键字，通过插入内存屏障。内存屏障是一种同步机制，用于确保在多线程环境下的内存操作的顺序性和可见性。它是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。内存屏障可以确保在它之前的所有内存操作都完成，并且它之后的内存操作都不会开始，直到它完成。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);